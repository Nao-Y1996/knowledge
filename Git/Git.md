# Git

## merge

merge する branch ＝ theirs
merge される branch ＝ ours
merge は ours のブランチで`git merge <theirs>`で行う

ours ブランチの状態が以前から変更されていなければ、fast-forward(早送り)マージになる
fast-foward マージではマージコミットは作成されない．
デフォの設定では ff マージできる時は ff マージになる．

## fast-forward マージのデメリット

- fast-forward である merge の場合 merge のコミットが発行されないため、master がその後更新されていった場合に topicA ブランチで行われた作業を参照するのが面倒になる。
- merge の取り消しを行いたいと思った場合かなり面倒。

## merge コミットが存在するメリット

- merge コミットの diff を見るだけでそのブランチで行われた作業を見るのが容易
- merge コミットを取り消すことで merge 作業自体をなかったことにしたい場合も簡単

--no-ff オプションをつけるとマージコミットが作成される．
以下のコマンドで常にその設定をしておくのが良い．

```
git config --global --add merge.ff false
```

## push の注意点

状況：develop から分岐した feature ブランチで開発をしている，feature を push したい
必ず master の最新を取り込んでから push する
ここで rebase などを用いてマージコミットを作らないようにすると良い（議論あり）

リモートの最新を取り込む（分岐をきれいにするため rebase を使う）

## コンフリクト時の対応

1. どのファイルがコンフリクトしているか以下のコマンドで確認する
   → 　 both modified のファイルがコンフリクトしているもの

   ```bash
   git status
   ```

2. コンフリクトのブランチがどの branch から分岐しているかを調べる
   → 　 23pjb252jbag5423nj24i のような分岐点のコミット ID が出力される

   ```bash
   git merge-base <ours> <theirs>
   ```

3. コンフリクトしている各ファイルに対して以下の 2 つで変更箇所を確認

   ```bash
   git diff <分岐点のコミットID> <ours> <ファイル名>
   git diff <分岐点のコミットID> <theirs> <ファイル名>
   ```

4. ファイルを編集してコンフリクトを解消する

5. 以下のコマンドでマージを完了する

   ```bash
   git merge –continue
   ```

## CI （継続的インテグレーション）

開発者が自分のコード変更を頻繁にリポジトリにマージし、その度に自動化されたビルドとテストを実行する（コードの変更がトリガー）。小さなサイクルでインテグレーションを繰り返し行い、インテグレーションのエラーを素早く修正する。
![CI](img/ci-cycle.png)
※[参照](https://www.techmatrix.co.jp/product/cisolution/cisolution1.html)

## CD（継続的デプロイメント）

コード変更からリリースまでに必要な検証を行う．
デプロイパイプラインという形での自動化

## CI/CD で実行されること

- 静的解析
  構文，コードスタイル，コードパターンのチェック
- 自動テスト
  単体・結合テスト，受け入れテスト
- 非機能要件のテスト
  性能，脆弱性
- アーカイブ作成
  デプロイ・リリースに使用するアーカイブ
- デプロイ，リリース

## GitLab CI

.gitlab-ci.yml ファイルにパイプラインの構造と実行順序を定義することで実装できる
※パイプライン
CI におけるパイプラインとは CI で行う各処理の流れをまとめたもの．
ハードウェア技術におけるパイプライン処理は、CPU などのプロセッサの性能を向上させるための技術のひとつであり、複数の命令を並行して実行するための方式
